<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis 字典的实现]]></title>
    <url>%2F2018%2F01%2F07%2Fredis-dict%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;最近研究了一下redis里面字典的实现，redis作为高效的内存存储而被广泛使用，内部实现的db结构以及多种高效的数据结构，其底层基本上就是靠字典来实现。而其字典数据结构是基于哈希表来实现的，其中一些特性的实现十分精妙。&ensp;&ensp;&ensp;&ensp;源码分析是基于3.2版本的，相关数据结构定义在dict.h/dict.c中。 数据结构&ensp;&ensp;在看具体的数据结构之前，首先我们来看一下redis里面字典整体的结构。dict就是整个字典的结构了，可以看到里面维护了一个指向dictType的成员，并且维护了一个有两个成员的数组，每个成员分别是一个dictht类型，这个便是哈希表的实现了。而每个哈希表类型里面又有一个数组，每个成员都是一个dictEntry类型。为什么设计的这么复杂呢？是因为这个哈希表结构提供了很多丰富的功能，具体提供了哪些功能呢？首先就需要看一下每个结构的定义。 节点数据结构&ensp;&ensp;&ensp;&ensp;哈希表中的节点定义为dictEntry，维护了key-val的值，并且整个哈希表是基于开链法实现的，所以每个节点还需要维护一个指向下一个节点的指针next，如下是哈希节点的定义： 12345678910typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; struct dictEntry *next;&#125; dictEntry; 哈希表数据结构&ensp;&ensp;&ensp;&ensp;哈希表的数据结构定义为dictht，size是初始哈希表的大小，而used是当前使用的大小，size会根据当前used的大小来做相应的调整，调整的过程就是字典动态扩容的过程，什么是动态扩容呢？具体的思想和过程下面会详细描述。sizemask始终等于size－1，这个是用来做掩码运算的，哈希算法算出一个index，通过index&amp;sizemask来计算具体的数组索引位置，这么做的原因是&amp;操作比％更快。而table便是具体的哈希节点数组了。 123456typedef struct dictht &#123; dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;&#125; dictht; 字典数据结构&ensp;&ensp;&ensp;&ensp;字典的数据结构定义为dict，type是函数指针类型，封装了哈希函数，key比较函数，释放内存函数等等。一个高效的哈希函数能保证哈希的结果尽量均匀分布，redis中的字符串哈希算法便是著名的开源算法MurmurHash2，但是因为上层的有不同的数据结构，所以实现了不同的哈希函数。可以看到，字典中维护两张哈希表，主要是用来做动态rehash的，rehashidx便是两张表动态rehash的索引。iterators是当前迭代器的个数，具体后面会详细介绍。 1234567typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ int iterators; /* number of iterators currently running */&#125; dict; 特性介绍&ensp;&ensp;&ensp;&ensp;redis的字典实现了很多特别的东西，如此花式造轮子的根本原因，还是作者从时间与空间上做了很多权衡。 动态扩容/缩容&ensp;&ensp;&ensp;&ensp;前面有提到动态扩容缩容，实际上不光是存储系统，一个设计良好的服务端系统也应该具备动态扩容缩容的特性。redis的数据都是放在第一张哈希表中ht[0]中的，所谓的动态扩容就是说ht[0]那张哈希表快不够用的时候，使用ht[1]来扩大哈希表的容量。这其中有两种方式，一种是redis提供了显示的扩容的接口dictExpand，供外部调用，另外一种是在添加数据的时候调用_dictExpandIfNeeded，以此来判断是否需要扩容。缩容就是当前哈希表使用率 used/size 低于某个值时，利用ht[1]缩小哈希表的容量。扩容和缩容的操作就是rehash的过程。 rehash+渐进式&ensp;&ensp;&ensp;&ensp;rehash就是将第一张ht[0]的数据迁移到ht[1]的过程，rehash实现了两种策略，一种是在定时器的每个tick里面，执行databasesCron操作的时候，还有一种是在增加查找删除等字典操作的时候执行，这样的过程可以保证rehash的时候不会阻塞redis服务器，对用户来说，也是无感知的。rehash的过程中维护了一个索引，就是上面介绍的字典结构中的rehashidx，使用这个索引遍历ht[0]，将数据无缝迁移到ht[1]。因为在rehash中的任何时刻，一个节点只能存在其中一张哈希表中，所以每次操作都需要处理两张表。 迭代器&ensp;&ensp;&ensp;&ensp;redis里面的字典实现了两种迭代器，一种是安全的迭代器，一种是普通的迭代器。所谓安全就是指在迭代的过程中可以执行添加查找等操作，非安全的迭代器就是只能执行迭代操作。其实本质上就是安全的迭代器会给dict设置iterators++（dict里面的变量），这样字典的各种操作就不会执行rehash操作，如果在迭代的过程中执行了rehash，迭代索引就会错乱。 相关接口创建字典1dict *dictCreate(dictType *type, void *privDataPtr); 目前redis中用到字典的地方有很多，包括全量的key，超时的key等等db中的kv， 命令回调表，hash结构，set结构，sortset结构等等。 添加数据1int dictAdd(dict *d, void *key, void *val); 前面说到会执行rehash操作，并且如果字典底层正在rehash，索引的计算会读取两张表来判断，并且数据只会添加到第二张表里面。 查找数据1dictEntry *dictFind(dict *d, const void *key) 查找数据，和添加数据很类似，唯一的区别是查找数据的时候不会计算是否需要扩容。 删除数据1int dictDelete(dict *d, const void *key); 删除数据，和添加数据的过程类似，但是在删除数据的过程中不做缩容操作，缩容是上层负责主动调用缩容接口htNeedsResize和dictResize。 迭代字典1dictEntry *dictNext(dictIterator *iter); 迭代字典，搭配dictGetIterator或者dictGetSafeIterator操作，前面有说到安全迭代器和非安全迭代器的区别，非安全的迭代器在初次迭代的时候会计算一个哈希值，释放迭代器的时候assert这个哈希值是否被改变了。 总结&ensp;&ensp;&ensp;&ensp;哈希表作为一种基础且重要的数据结构，很多开源项目都有自己的实现，而阅读redis中字典的实现的时候，会觉得很多地方的思考实在是有趣。包括它的一些特性，例如：动态扩容缩容，渐进式rehash等等，所有这些特性的出发点其实都是基于充分的使用内存。]]></content>
  </entry>
</search>
