<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go web编程之-beego框架]]></title>
    <url>%2F2018%2F01%2F01%2Fbeego-introduce%2F</url>
    <content type="text"><![CDATA[引言&nbsp;&nbsp;&nbsp;&nbsp;下半年一直在研究go语言，学习了go语言的语法，研究了go语言的一些底层机制，包括协程，调度，channel，类型系统等等。也使用go语言的web框架beego搭建了两个小型的web系统。之前一直做的是游戏后台，应用后台，很少接触web后台，这一次也算是对web后台做了一些深入的研究，包括RESTful api，http/https，cookie/session，爬虫，登录系统，反向代理等等相关知识。项目代码大概码了千行，遗憾的是，项目没有过多的资源再深入进行下去。一切始于beego，所以觉得有必要对beego框架做一个总结，算是个人web开发技术栈上的一环。 &nbsp;&nbsp;&nbsp;&nbsp;项目前期调研的时候，技术方向上选择了go语言，最开始是准备自己来实现一个web后台，因为go语言本身提供了很多丰富的http库，可以很方便的构建web服务，但是实现的过程中发现了很多的阻力。项目组同事开会讨论的时候都觉得还是使用一个开源框架好一点，避免踩坑。于是开始调研go语言的一些web框架，包括gin，echo，beego等等，考虑到gin和echo这一类的过于轻量，我们也没有太多的web开发的经验，而beego的思想源于python的django和flask，后面两个我之前有一定了解，所以选定了beego，实时证明beego的简洁，文档的完善，社区的活跃，使我们做到了快速的迭代。 beego的使用&nbsp;&nbsp;&nbsp;&nbsp;beego是国人开发的，作者是astaxie，目前的版本是1.9.1，官方文档在beego.me。beego本身是一个MVC模式的框架，所以可以使用它来构建MVC模式的web服务，也可以使用它来构建RESTful的纯API服务。 &nbsp;&nbsp;&nbsp;&nbsp;要使用beego框架，首先要有一套标准的go开发环境，这里就不介绍了，具体可以看go语言官网文档，有了go开发环境，我们就可以开始安装beego的开发环境了。 beego框架和bee工具首先在src目录下面，执行如下的命令，拉取beego框架和bee工具 1$ go get github.com/astaxie/beego 1$ go get github.com/beego/bee bee会安装到#GOPATH/bin下面，所以需要将#GOPATH/bin目录加入环境变量中 1$ export PATH=$PATH:$(go env GOPATH)/bin 创建服务创建beego项目，使用bee命令即可，前面我们说到beego可以创建两种服务，都集成在bee命令中： bee new webproject 创建一个MVC框架的项目 bee api apiproject 创建一个Restful api项目 因为我的项目都是纯api的服务，所以我也以创建api服务举例子，比如这里我创建一个api的项目 beego框架会自动帮我们生成相关的模块，beego创建的模块目录如下 运行服务要运行创建的beego项目，只需要执行bee run，将会得到如下的提示信息 访问服务访问ip:8080端口便可以看到beego服务已经启动起来了 可以看到，使用beego框架创建http服务过程非常简单，接下来我们就可以完善我们的功能了。 框架分析虽然MVC架构中有Model(模式)-View(视图)-Controller(控制器)，在一个提供api的服务中也可以抽象出模式和控制器，只是没有视图罢了。 controllerbeego最核心的概念就是控制器了，要使用控制器，首先我们要定义自己的控制器struct，使用bee api命令创建的模板已经定义好了两个controler，ObjectController和UserController。他们匿名组合了beego.Controller，这样就可以使用beego.Controller定义的一些接口，比如：1Prepare() 这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。 1Get()，Post()，Delete()，Put()，Head() 如果用户请求的 HTTP Method 是其中的一种，那么就执行该函数，用户继承的子 struct 中可以实现了该方法以处理这个请求。 1Finish() 这个函数是在执行完相应的 HTTP Method 方法之后执行的，默认是空，用户可以在子 struct 中重写这个函数，执行例如数据库关闭，清理数据之类的工作。 当然我们的控制器也可以自己定义一些接口，那么最核心的问题是这些接口怎么对外提供服务呢？这就需要路由的功能了。 路由设置我认为beego的灵活性的一个特点，在于它提供了强大的路由功能，包括后面要讲到的自动API文档的功能，让我这种之前很少接触web后台开发的人来说，虎躯一震。。。 固定路由1234beego.Router(&quot;/&quot;, &amp;controllers.MainController&#123;&#125;)beego.Router(&quot;/admin&quot;, &amp;admin.UserController&#123;&#125;)beego.Router(&quot;/admin/index&quot;, &amp;admin.ArticleController&#123;&#125;)beego.Router(&quot;/admin/addpkg&quot;, &amp;admin.AddController&#123;&#125;) 这种是最常用也是最简单的了，一个路由，一个控制器，根据请求的方法get, post, head路由到特定的函数,Get(),Post(),Head()等等 自定义方法及RESTful路由固定路由不够灵活，controller里面必须要以特定的方法作为函数名。beego提供了更加灵活的方式，用户可以自定义函数名，然后使用如下的方法 1beego.Router(&quot;/&quot;,&amp;IndexController&#123;&#125;,&quot;method:funcname&quot;) 多个Method对应一个函数 1beego.Router(&quot;/api&quot;,&amp;RestController&#123;&#125;,&quot;get,post:ApiFunc&quot;) 多个Method对应不同函数 1beego.Router(&quot;/simple&quot;,&amp;SimpleController&#123;&#125;,&quot;get:GetFunc;post:PostFunc&quot;) 是不是很非常6。。。 正则路由beego还提供了正则路由 123beego.Router(“/api/:id”, &amp;controllers.RController&#123;&#125;)beego.Router(“/:id:int”, &amp;controllers.RController&#123;&#125;)beego.Router(“/:id:string”, &amp;controllers.RController&#123;&#125;) 当然我认为不要过多的依赖这种方式，毕竟路由里面加上正则很容易乱，不好维护 注解路由除了上面说的几种路由，beego还提供了更强大的注解路由，注解路由是指，用户不需要注册路由了，只需要在router.go中Include相应地controller，然后在controller的method方法上面写上路由注释就可以了。 注解路由最强大的地方在于可以结合swagger做API文档自动化，非常方便，后面我会详细介绍。 数据处理路由注册之后，拿到请求的数据，该如何处理呢？beego提供了一组api可以获取http请求的数据 获取query参数12345GetString(key string) stringGetStrings(key string) []stringGetInt(key string) (int64, error)GetBool(key string) (bool, error)GetFloat(key string) (float64, error) 获取正则变量这种对应于前面的正则路由 1this.Ctx.Input.Param(&quot;:id&quot;) 获取json数据有的时候，我们会把请求的json数据放到Request Body，该如何将这个json数据解析到对应的struct中呢？ 12var ob models.Objectjson.Unmarshal(this.Ctx.Input.RequestBody, &amp;ob) 获取form数据也可以使用struct的tag来直接解析表单的数据，例如，我们定义一个表单123456&lt;form id="user"&gt; 名字：&lt;input name="username" type="text" /&gt; 年龄：&lt;input name="age" type="text" /&gt; 邮箱：&lt;input name="Email" type="text" /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 然后定义一个struct123456type user struct &#123; Id int `form:"-"` Name interface&#123;&#125; `form:"username"` Age int `form:"age"` Email string&#125; 最后进行解析123456func (this *MainController) Post() &#123; u := user&#123;&#125; if err := this.ParseForm(&amp;u); err != nil &#123; //handle error &#125;&#125; 日志模块beego的日志模块也非常的好用，只需要 123import ( "github.com/astaxie/beego/logs") 12345logs.SetLogger("console") #打印日志信息到consolebeego.SetLogger("file", `&#123;"filename":"logs/app.log"&#125;`) #打印日志信息到文件beego.SetLevel(loglevel) #设置日志的级别，1-7,7表示trace级别beego.SetLogFuncCall(true) #输出文件名和行号beego.Debug，beego.Info，beego.Fatal #调用相应的日志函数了 开启httpsweb服务器必须要考虑安全问题，要使用beego提供的https功能，只需要在app.conf中做如下的配置即可，其中的公钥和证书需要自己生成 1234enablehttptls=truehttpsport=8080httpscertfile=tls1/server.crthttpskeyfile=tls1/server.key 文档自动化web开发从早期的MVC模式渐渐发展到现在的前后端分离模式，前台和后台只干自己的事情，这样可以大大提高开发的效率，后台只提供RESTful的接口，前端负责展示的逻辑，这其中有一个问题就是接口联调的时候该如何约定？swagger应运而生。通过swagger-ui定义接口，前后端可以不依赖于部署的服务，灵活的调试接口。而beego则整合了swagger的功能，可以方便的自动生成swagger描述语言。 配置首先必须要在router.go中开头加上如下的注释 1234567// @APIVersion 1.0.0// @Title beego Test API// @Description beego has a very cool tools to autogenerate documents for your API// @Contact astaxie@gmail.com// @TermsOfServiceUrl http://beego.me/// @License Apache 2.0// @LicenseUrl http://www.apache.org/licenses/LICENSE-2.0.html 然后在main.go中写一个如下的配置 1234if beego.BConfig.RunMode == "dev" &#123; beego.BConfig.WebConfig.DirectoryIndex = true beego.BConfig.WebConfig.StaticDir["/swagger"] = "swagger"&#125; 路由设置目前beego集成swagger只支持namespace+Include的路由写法 1234567891011func init() &#123; ns := beego.NewNamespace("/api", beego.NSNamespace("/agentinfo", beego.NSInclude( &amp;controllers.AgentController&#123;&#125;, ), ), ) beego.AddNamespace(ns)&#125; 应用注释比如我们提供了一个这样的接口，这里的lang是一个swagger路径参数，类型是string, agentinfo是一个dao.AddAgentInfo类型的对象 12345678910111213141516// @Title AddAgentConfInfo// @Description set the agent info// @Param lang path string true "The lang"// @Param agentinfo body dao.AddAgentInfo true "The json agentinfo"// @Success 201 "Created"// @Failure 403 "Forbidden"// @router /:lang [Post]func (this *AgentController) AddAgentConfInfo() &#123; lang := this.Ctx.Input.Param(":lang") beego.Info("AddAgentConfInfo, lang:", lang) var agentinfo dao.AddAgentInfo json.Unmarshal([]byte(this.Ctx.Input.RequestBody), &amp;agentinfo) beego.Info("AddAgentConfInfo, agentinfo:", agentinfo)&#125; 然后执行，bee run -gendoc=true -downdoc=true，gendoc表示根据注释生成新的swagger文档，downdoc表示下载swagger相关的组件 跨域问题客户端调试的时候可能会遇到跨域访问的问题，服务器需要支持，搜索并测试了好久，目前我的做法是在router.go开头加上 12345678beego.InsertFilter("*", beego.BeforeRouter, cors.Allow(&amp;cors.Options&#123; AllowOrigins: []string&#123;"*"&#125;, //AllowAllOrigins: true, AllowMethods: []string&#123;"GET", "POST", "PUT", "DELETE", "OPTIONS"&#125;, AllowHeaders: []string&#123;"Origin", "Authorization", "Access-Control-Allow-Origin", "Access-Control-Allow-Headers", "Content-Type", "X-Pingother", "X-Requested-With"&#125;, ExposeHeaders: []string&#123;"Content-Length", "Access-Control-Allow-Origin", "Access-Control-Allow-Headers", "Content-Type"&#125;, AllowCredentials: true, &#125;)) 总结至此，beego框架算是做了一个完整的简介了，beego给我的感觉就是智能，简便，符合go的设计思想。希望以后有机会能多深入的使用这个框架，并且贡献一些自己的代码。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>beego</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis 字典的实现]]></title>
    <url>%2F2017%2F12%2F01%2Fredis-dict%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;最近研究了一下redis里面字典的实现，redis作为高效的内存存储而被广泛使用，内部实现的db结构以及多种高效的数据结构，其底层基本上就是靠字典来实现。而其字典数据结构是基于哈希表来实现的，其中一些特性的实现十分精妙。&ensp;&ensp;&ensp;&ensp;源码分析是基于3.2版本的，相关数据结构定义在dict.h/dict.c中。 数据结构&ensp;&ensp;在看具体的数据结构之前，首先我们来看一下redis里面字典整体的结构。dict就是整个字典的结构了，可以看到里面维护了一个指向dictType的成员，并且维护了一个有两个成员的数组，每个成员分别是一个dictht类型，这个便是哈希表的实现了。而每个哈希表类型里面又有一个数组，每个成员都是一个dictEntry类型。为什么设计的这么复杂呢？是因为这个哈希表结构提供了很多丰富的功能，具体提供了哪些功能呢？首先就需要看一下每个结构的定义。 节点数据结构&ensp;&ensp;&ensp;&ensp;哈希表中的节点定义为dictEntry，维护了key-val的值，并且整个哈希表是基于开链法实现的，所以每个节点还需要维护一个指向下一个节点的指针next，如下是哈希节点的定义： 12345678910typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; struct dictEntry *next;&#125; dictEntry; 哈希表数据结构&ensp;&ensp;&ensp;&ensp;哈希表的数据结构定义为dictht，size是初始哈希表的大小，而used是当前使用的大小，size会根据当前used的大小来做相应的调整，调整的过程就是字典动态扩容的过程，什么是动态扩容呢？具体的思想和过程下面会详细描述。sizemask始终等于size－1，这个是用来做掩码运算的，哈希算法算出一个index，通过index&amp;sizemask来计算具体的数组索引位置，这么做的原因是&amp;操作比％更快。而table便是具体的哈希节点数组了。 123456typedef struct dictht &#123; dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;&#125; dictht; 字典数据结构&ensp;&ensp;&ensp;&ensp;字典的数据结构定义为dict，type是函数指针类型，封装了哈希函数，key比较函数，释放内存函数等等。一个高效的哈希函数能保证哈希的结果尽量均匀分布，redis中的字符串哈希算法便是著名的开源算法MurmurHash2，但是因为上层的有不同的数据结构，所以实现了不同的哈希函数。可以看到，字典中维护两张哈希表，主要是用来做动态rehash的，rehashidx便是两张表动态rehash的索引。iterators是当前迭代器的个数，具体后面会详细介绍。 1234567typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ int iterators; /* number of iterators currently running */&#125; dict; 特性介绍&ensp;&ensp;&ensp;&ensp;redis的字典实现了很多特别的东西，如此花式造轮子的根本原因，还是作者从时间与空间上做了很多权衡。 动态扩容/缩容&ensp;&ensp;&ensp;&ensp;前面有提到动态扩容缩容，实际上不光是存储系统，一个设计良好的服务端系统也应该具备动态扩容缩容的特性。redis的数据都是放在第一张哈希表中ht[0]中的，所谓的动态扩容就是说ht[0]那张哈希表快不够用的时候，使用ht[1]来扩大哈希表的容量。这其中有两种方式，一种是redis提供了显示的扩容的接口dictExpand，供外部调用，另外一种是在添加数据的时候调用_dictExpandIfNeeded，以此来判断是否需要扩容。缩容就是当前哈希表使用率 used/size 低于某个值时，利用ht[1]缩小哈希表的容量。扩容和缩容的操作就是rehash的过程。 rehash+渐进式&ensp;&ensp;&ensp;&ensp;rehash就是将第一张ht[0]的数据迁移到ht[1]的过程，rehash实现了两种策略，一种是在定时器的每个tick里面，执行databasesCron操作的时候，还有一种是在增加查找删除等字典操作的时候执行，这样的过程可以保证rehash的时候不会阻塞redis服务器，对用户来说，也是无感知的。rehash的过程中维护了一个索引，就是上面介绍的字典结构中的rehashidx，使用这个索引遍历ht[0]，将数据无缝迁移到ht[1]。因为在rehash中的任何时刻，一个节点只能存在其中一张哈希表中，所以每次操作都需要处理两张表。 迭代器&ensp;&ensp;&ensp;&ensp;redis里面的字典实现了两种迭代器，一种是安全的迭代器，一种是普通的迭代器。所谓安全就是指在迭代的过程中可以执行添加查找等操作，非安全的迭代器就是只能执行迭代操作。其实本质上就是安全的迭代器会给dict设置iterators++（dict里面的变量），这样字典的各种操作就不会执行rehash操作，如果在迭代的过程中执行了rehash，迭代索引就会错乱。 相关接口创建字典1dict *dictCreate(dictType *type, void *privDataPtr); 目前redis中用到字典的地方有很多，包括全量的key，超时的key等等db中的kv， 命令回调表，hash结构，set结构，sortset结构等等。 添加数据1int dictAdd(dict *d, void *key, void *val); 前面说到会执行rehash操作，并且如果字典底层正在rehash，索引的计算会读取两张表来判断，并且数据只会添加到第二张表里面。 查找数据1dictEntry *dictFind(dict *d, const void *key) 查找数据，和添加数据很类似，唯一的区别是查找数据的时候不会计算是否需要扩容。 删除数据1int dictDelete(dict *d, const void *key); 删除数据，和添加数据的过程类似，但是在删除数据的过程中不做缩容操作，缩容是上层负责主动调用缩容接口htNeedsResize和dictResize。 迭代字典1dictEntry *dictNext(dictIterator *iter); 迭代字典，搭配dictGetIterator或者dictGetSafeIterator操作，前面有说到安全迭代器和非安全迭代器的区别，非安全的迭代器在初次迭代的时候会计算一个哈希值，释放迭代器的时候assert这个哈希值是否被改变了。 总结&ensp;&ensp;&ensp;&ensp;哈希表作为一种基础且重要的数据结构，很多开源项目都有自己的实现，而阅读redis中字典的实现的时候，会觉得很多地方的思考实在是有趣。包括它的一些特性，例如：动态扩容缩容，渐进式rehash等等，所有这些特性的出发点其实都是基于充分的使用内存。]]></content>
      <categories>
        <category>nosql</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>哈希表</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
</search>
